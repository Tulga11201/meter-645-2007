#define EVENT_SEPARATE_C
#include <includes.h>

#if REDEF_FILE_LINE_EN > 0
#line  __LINE__ "H13"
#endif

#define EVENT_DATA_LEN 700

CONST PROTO_DI CONST_PDI0[] =
{
  //a                         34
   _PDI_CUR_TIME, //发生时刻, 6     (上1次）A相失压发生时刻                  
  0x00010000,   //正向有功总, 4           			（上1次）A相失压发生时刻正向有功总电能  					
  0x00020000,   //反向有功总, 4                （上1次）A相失压发生时刻反向有功总电能  
  0x00030000,   //组合无功1, 4                 （上1次）A相失压发生时刻组合无功1总电能 
  0x00040000,   //组合无功2, 4                 （上1次）A相失压发生时刻组合无功2总电能                                                                        
  0x00150000,   //A相正向有功总, 4             （上1次）A相失压发生时刻A相正向有功电能 
  0x00160000,   //A相反向有功总, 4             （上1次）A相失压发生时刻A相反向有功电能 
  0x00170000,   //A相组合无功1,  4             （上1次）A相失压发生时刻A相组合无功1电能
  //b                          25 
  0x00180000,   //A相组合无功2,  4    /         （上1次）A相失压发生时刻A相组合无功2电能
  0x02010100,   //A相电压   2                  （上1次）A相失压发生时刻A相电压         
  0x02020100,   //A相电流   3                  （上1次）A相失压发生时刻A相电流         
  0x02030100,   //A相有功功率   3              （上1次）A相失压发生时刻A相有功功率    
  
  0x02040100,   //A相无功功率   3              （上1次）A相失压发生时刻A相无功功率     
  0x02060100,   //A相功率因素   2              （上1次）A相失压发生时刻A相功率因数                                                                         
  0x00290000,   //B相正向有功总   4  /           （上1次）A相失压发生时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总   4   /          （上1次）A相失压发生时刻B相反向有功电能 
  //c                            26    
  0x002B0000,   //B相组合无功1    4      /       （上1次）A相失压发生时刻B相组合无功1电能
  0x002C0000,   //B相组合无功2   4    /          （上1次）A相失压发生时刻B相组合无功2电能
  0x02010200,   //B相电压       2               （上1次）A相失压发生时刻B相电压         
  0x02020200,   //B相电流      3                （上1次）A相失压发生时刻B相电流     
  
  0x02030200,   //B相有功功率   3               （上1次）A相失压发生时刻B相有功功率     
  0x02040200,   //B相无功功率   3               （上1次）A相失压发生时刻B相无功功率     
  0x02060200,   //B相功率因素     2             （上1次）A相失压发生时刻B相功率因数                                                                         
  0x003D0000,   //C相正向有功总   4  /           （上1次）A相失压发生时刻C相正向有功电能 
  //d                             25            
  0x003E0000,   //C相反向有功总  4  /            （上1次）A相失压发生时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1    4  /           （上1次）A相失压发生时刻C相组合无功1电能
  0x00400000,   //C相组合无功2   4   /           （上1次）A相失压发生时刻C相组合无功2电能
  0x02010300,   //C相电压      2                （上1次）A相失压发生时刻C相电压  
  
  0x02020300,   //C相电流       3               （上1次）A相失压发生时刻C相电流         
  0x02030300,   //C相有功功率   3               （上1次）A相失压发生时刻C相有功功率     
  0x02040300,   //C相无功功率   3               （上1次）A相失压发生时刻C相无功功率     
  0x02060300,   //C相功率因素    2              （上1次）A相失压发生时刻C相功率因数     
  //e                        34      
  _PDI_TOTAL_AH,       //      4 //                  （上1次）A相失压期间总安时数   
  _PDI_A_AH,             //    4   //                （上1次）A相失压期间A相安时数  
  _PDI_B_AH,               // 4        ///            （上1次）A相失压期间B相安时数 
  _PDI_C_AH,                //4       //              （上1次）A相失压期间C相安时数 
  
   _PDI_CUR_TIME,  //结束时刻, 6					（上1次）A相失压结束时刻    
  0x00010000,   //正向有功总, 4         （上1次）A相失压结束时刻正向有功总电能  
  0x00020000,   //反向有功总, 4         （上1次）A相失压结束时刻反向有功总电能  
  0x00030000,   //组合无功1, 4          （上1次）A相失压结束时刻组合无功1总电能 
  //f                        32       
  0x00040000,   //组合无功2, 4          （上1次）A相失压结束时刻组合无功2总电能 
  0x00150000,   //A相正向有功总, 4      （上1次）A相失压结束时刻A相正向有功电能 
  0x00160000,   //A相反向有功总, 4      （上1次）A相失压结束时刻A相反向有功电能 
  0x00170000,   //A相组合无功1,  4      （上1次）A相失压结束时刻A相组合无功1电能
  
  0x00180000,   //A相组合无功2,  4      （上1次）A相失压结束时刻A相组合无功2电能 
  0x00290000,   //B相正向有功总   4      （上1次）A相失压结束时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总  4       （上1次）A相失压结束时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1   4       （上1次）A相失压结束时刻B相组合无功1电能
  //g                           20         
  0x002C0000,   //B相组合无功2   4       （上1次）A相失压结束时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总  4       （上1次）A相失压结束时刻C相正向有功电能 
  0x003E0000,   //C相反向有功总  4       （上1次）A相失压结束时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1   4       （上1次）A相失压结束时刻C相组合无功1电能
  0x00400000,   //C相组合无功2    4      （上1次）A相失压结束时刻C相组合无功2电能
  
};

CONST PROTO_DI CONST_PDI1[]=
{_PDI_ALL_LOSS_VOL_START_TIME, //发生时刻
  _PDI_ALL_LOSS_VOL_CUR,  //发生时电流
  _PDI_ALL_LOSS_VOL_END_TIME,  //结束时刻
  };

CONST PROTO_DI CONST_PDI2[]=
{_PDI_CUR_TIME, //发生时刻, 6       （上1次）A相失流发生时刻                
  0x00010000,   //正向有功总, 4                    （上1次）A相失流发生时刻正向有功总电能  
  0x00020000,   //反向有功总, 4                    （上1次）A相失流发生时刻反向有功总电能  
  0x00030000,   //组合无功1, 4                     （上1次）A相失流发生时刻组合无功1总电能
  
  0x00040000,   //组合无功2, 4                     （上1次）A相失流发生时刻组合无功2总电能 
  0x00150000,   //A相正向有功总, 4                 （上1次）A相失流发生时刻A相正向有功电能 
  0x00160000,   //A相反向有功总, 4                 （上1次）A相失流发生时刻A相反向有功电能 
  0x00170000,   //A相组合无功1,  4                 （上1次）A相失流发生时刻A相组合无功1电能
  //B     25       
  0x00180000,   //A相组合无功2,  4                 （上1次）A相失流发生时刻A相组合无功2电能
  0x02010100,   //A相电压   2                      （上1次）A相失流发生时刻A相电压         
  0x02020100,   //A相电流   3                      （上1次）A相失流发生时刻A相电流         
  0x02030100,   //A相有功功率   3                  （上1次）A相失流发生时刻A相有功功率  
  
  0x02040100,   //A相无功功率   3                  （上1次）A相失流发生时刻A相无功功率     
  0x02060100,   //A相功率因素   2                  （上1次）A相失流发生时刻A相功率因数     
  0x00290000,   //B相正向有功总  4                  （上1次）A相失流发生时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总 4                  （上1次）A相失流发生时刻B相反向有功电能 
  //C       25   
  0x002B0000,   //B相组合无功1   4                  （上1次）A相失流发生时刻B相组合无功1电能
  0x002C0000,   //B相组合无功2     4                （上1次）A相失流发生时刻B相组合无功2电能
  0x02010200,   //B相电压      2                    （上1次）A相失流发生时刻B相电压         
  0x02020200,   //B相电流        3                  （上1次）A相失流发生时刻B相电流   
  
  0x02030200,   //B相有功功率  3                    （上1次）A相失流发生时刻B相有功功率     
  0x02040200,   //B相无功功率    3                  （上1次）A相失流发生时刻B相无功功率     
  0x02060200,   //B相功率因素    2                  （上1次）A相失流发生时刻B相功率因数     
  0x003D0000,   //C相正向有功总   4                 （上1次）A相失流发生时刻C相正向有功电能 
  //D         25   
  0x003E0000,   //C相反向有功总   4                 （上1次）A相失流发生时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1   4                  （上1次）A相失流发生时刻C相组合无功1电能
  0x00400000,   //C相组合无功2   4                  （上1次）A相失流发生时刻C相组合无功2电能
  0x02010300,   //C相电压      2                    （上1次）A相失流发生时刻C相电压  
  
  0x02020300,   //C相电流      3                    （上1次）A相失流发生时刻C相电流         
  0x02030300,   //C相有功功率   3                  （上1次）A相失流发生时刻C相有功功率     
  0x02040300,   //C相无功功率   3                   （上1次）A相失流发生时刻C相无功功率     
  0x02060300,   //C相功率因素   2	           （上1次）A相失流发生时刻C相功率因数
  //E          34
  _PDI_CUR_TIME,  //结束时刻, 6                    （上1次）A相失流结束时刻   
  0x00010000,   //正向有功总, 4    		 （上1次）A相失流结束时刻正向有功总电能    
  0x00020000,   //反向有功总, 4                   （上1次）A相失流结束时刻反向有功总电能  
  0x00030000,   //组合无功1, 4                    （上1次）A相失流结束时刻组合无功1总电能 
  
  0x00040000,   //组合无功2, 4                    （上1次）A相失流结束时刻组合无功2总电能 
  0x00150000,   //A相正向有功总, 4                （上1次）A相失流结束时刻A相正向有功电能 
  0x00160000,   //A相反向有功总, 4                （上1次）A相失流结束时刻A相反向有功电能 
  0x00170000,   //A相组合无功1,  4                （上1次）A相失流结束时刻A相组合无功1电能
  //F        32     
  0x00180000,   //A相组合无功2,  4                （上1次）A相失流结束时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4                （上1次）A相失流结束时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总   4                （上1次）A相失流结束时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1    4                （上1次）A相失流结束时刻B相组合无功1电能
  
  0x002C0000,   //B相组合无功2   4                 （上1次）A相失流结束时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总  4                 （上1次）A相失流结束时刻C相正向有功电能 
  0x003E0000,   //C相反向有功总  4                 （上1次）A相失流结束时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1  4                  （上1次）A相失流结束时刻C相组合无功1电能
  //G          4  
  0x00400000,   //C相组合无功2   4                 （上1次）A相失流结束时刻C相组合无功2电能

  };

CONST PROTO_DI CONST_PDI3[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  };

CONST PROTO_DI CONST_PDI4[]=
{_PDI_CUR_TIME, //发生时刻6      (上1次）电压逆相序发生时刻                                  
  0x00010000,   //正向有功总, 4   /            （上1次）电压逆相序发生时刻正向有功总电能                  
  0x00020000,   //反向有功总 4   /             （上1次）电压逆相序发生时刻反向有功总电能                  
  0x00030000,   //组合无功1   4  /              （上1次）电压逆相序发生时刻组合无功1总电能   
  
  0x00040000,   //组合无功2  4 /                （上1次）电压逆相序发生时刻组合无功2总电能                 
  0x00150000,   //A相正向有功总 4  /            （上1次）电压逆相序发生时刻A相正向有功电能                 
  0x00160000,   //A相反向有功总 4 /             （上1次）电压逆相序发生时刻A相反向有功电能                       
  0x00170000,   //A相组合无功1  4 /             （上1次）电压逆相序发生时刻A相组合无功1电能 
  //B          32        
  0x00180000,   //A相组合无功2  4/             （上1次）电压逆相序发生时刻A相组合无功2电能                      
  0x00290000,   //B相正向有功总  4 /            （上1次）电压逆相序发生时刻B相正向有功电能                       
  0x002A0000,   //B相反向有功总  4  /           （上1次）电压逆相序发生时刻B相反向有功电能                       
  0x002B0000,   //B相组合无功1    4  /          （上1次）电压逆相序发生时刻B相组合无功1电能
  
  0x002C0000,   //B相组合无功2    4   /         （上1次）电压逆相序发生时刻B相组合无功2电能                      
  0x003D0000,   //C相正向有功总   4    /        （上1次）电压逆相序发生时刻C相正向有功电能                       
  0x003E0000,   //C相反向有功总   4   /         （上1次）电压逆相序发生时刻C相反向有功电能                       
  0x003F0000,   //C相组合无功1    4    /        （上1次）电压逆相序发生时刻C相组合无功1电能 
  //C           34
  0x00400000,   //C相组合无功2    4     /       （上1次）电压逆相序发生时刻C相组合无功2电能
  _PDI_CUR_TIME,  //结束时刻 	6			（上1次）电压逆相序结束时刻  
  0x00010000,   //正向有功总, 4               （上1次）电压逆相序结束时刻正向有功总电能  
  0x00020000,   //反向有功总   4               （上1次）电压逆相序结束时刻反向有功总电能  
  0x00030000,   //组合无功1   4                （上1次）电压逆相序结束时刻组合无功1总电能 
  0x00040000,   //组合无功2  4                 （上1次）电压逆相序结束时刻组合无功2总电能 
  0x00150000,   //A相正向有功总   4            （上1次）电压逆相序结束时刻A相正向有功电能 
  0x00160000,   //A相反向有功总   4            （上1次）电压逆相序结束时刻A相反向有功电能 
  //D         32     
  0x00170000,   //A相组合无功1    4            （上1次）电压逆相序结束时刻A相组合无功1电能
  0x00180000,   //A相组合无功2    4            （上1次）电压逆相序结束时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4            （上1次）电压逆相序结束时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总   4            （上1次）电压逆相序结束时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1    4            （上1次）电压逆相序结束时刻B相组合无功1电能
  0x002C0000,   //B相组合无功2    4            （上1次）电压逆相序结束时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总    4           （上1次）电压逆相序结束时刻C相正向有功电能 
  0x003E0000,   //C相反向有功总   4            （上1次）电压逆相序结束时刻C相反向有功电能 
  //F           8
  0x003F0000,   //C相组合无功1    4            （上1次）电压逆相序结束时刻C相组合无功1电能
  0x00400000,   //C相组合无功2    4            （上1次）电压逆相序结束时刻C相组合无功2电能
                                                             
  };

CONST PROTO_DI CONST_PDI5[]=
{ _PDI_CUR_TIME, //发生时刻6       （上1次）电压不平衡发生时刻                                                                  
  0x00010000,   //正向有功总    4                 （上1次）电压不平衡发生时刻正向有功总电能  
  0x00020000,   //反向有功总    4                 （上1次）电压不平衡发生时刻反向有功总电能  
  0x00030000,   //组合无功1    4                  （上1次）电压不平衡发生时刻组合无功1总电能 
  
  0x00040000,   //组合无功2    4                  （上1次）电压不平衡发生时刻组合无功2总电能 
  0x00150000,   //A相正向有功总  4                （上1次）电压不平衡发生时刻A相正向有功电能 
  0x00160000,   //A相反向有功总  4                （上1次）电压不平衡发生时刻A相反向有功电能 
  0x00170000,   //A相组合无功1    4               （上1次）电压不平衡发生时刻A相组合无功1电能
  //B        32 
  0x00180000,   //A相组合无功2    4               （上1次）电压不平衡发生时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4               （上1次）电压不平衡发生时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总    4              （上1次）电压不平衡发生时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1     4              （上1次）电压不平衡发生时刻B相组合无功1电能
  
  0x002C0000,   //B相组合无功2     4              （上1次）电压不平衡发生时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总    4              （上1次）电压不平衡发生时刻C相正向有功电能 
  0x003E0000,   //C相反向有功总   4               （上1次）电压不平衡发生时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1    4               （上1次）电压不平衡发生时刻C相组合无功1电能
  //C        32
  0x00400000,   //C相组合无功2    4               （上1次）电压不平衡发生时刻C相组合无功2电能
  _PDI_VOLT_MAX_UNBALANCE,  //最大电压不平衡率 2  （上1次）电压不平衡最大不平衡率                 
  _PDI_CUR_TIME, //结束时刻  6                     （上1次）电压不平衡结束时刻    
  0x00010000,   //正向有功总    4        	 (上1次）电压不平衡结束时刻正向有功总电能    
  0x00020000,   //反向有功总     4                （上1次）电压不平衡结束时刻反向有功总电能  
  0x00030000,   //组合无功1     4                 （上1次）电压不平衡结束时刻组合无功1总电能 
  0x00040000,   //组合无功2     4                 （上1次）电压不平衡结束时刻组合无功2总电能 
  0x00150000,   //A相正向有功总  4                （上1次）电压不平衡结束时刻A相正向有功电能 
  //D       32    
  0x00160000,   //A相反向有功总    4              （上1次）电压不平衡结束时刻A相反向有功电能 
  0x00170000,   //A相组合无功1   4                （上1次）电压不平衡结束时刻A相组合无功1电能
  0x00180000,   //A相组合无功2    4               （上1次）电压不平衡结束时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4               （上1次）电压不平衡结束时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总   4               （上1次）电压不平衡结束时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1    4               （上1次）电压不平衡结束时刻B相组合无功1电能
  0x002C0000,   //B相组合无功2    4               （上1次）电压不平衡结束时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总   4               （上1次）电压不平衡结束时刻C相正向有功电能 
  //E       12
  0x003E0000,   //C相反向有功总   4               （上1次）电压不平衡结束时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1    4               （上1次）电压不平衡结束时刻C相组合无功1电能
  0x00400000,   //C相组合无功2    4               （上1次）电压不平衡结束时刻C相组合无功2电能
                                                                                          
  };

CONST PROTO_DI CONST_PDI6[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_POS_ACTIVE_DEMAND,
  _PDI_POS_ACTIVE_DEMAND_TIME,  //正向有功最大需量时间
  };

CONST PROTO_DI CONST_PDI7[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_NEG_ACTIVE_DEMAND,
  _PDI_NEG_ACTIVE_DEMAND_TIME,  //反向有功最大需量时间
  };

CONST PROTO_DI CONST_PDI8[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_QUAD1_REACT_DEMAND,
  _PDI_QUAD1_REACT_DEMAND_TIME,  //第一象限无功最大需量时间
  };

CONST PROTO_DI CONST_PDI9[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_QUAD2_REACT_DEMAND,
  _PDI_QUAD2_REACT_DEMAND_TIME,  //第二象限无功最大需量时间
  };

CONST PROTO_DI CONST_PDI10[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_QUAD3_REACT_DEMAND,
  _PDI_QUAD3_REACT_DEMAND_TIME,  //第三象限无功最大需量时间
  };

CONST PROTO_DI CONST_PDI11[]=
{_PDI_CUR_TIME, //发生时刻
  _PDI_CUR_TIME,  //结束时刻
  _PDI_QUAD4_REACT_DEMAND,
  _PDI_QUAD4_REACT_DEMAND_TIME,  //第四象限无功最大需量时间
  };

CONST PROTO_DI CONST_PDI12[]=
{_PDI_PROG_TIME, //发生时刻6 
  _PDI_PROG_OP_ID,  //操作者代码 4
  _PDI_PROG_DI,  //编程的标识 40
  };

CONST PROTO_DI CONST_PDI13[]=
{_PDI_CUR_TIME, //发生时刻, 6
  _PDI_OPERATOR_ID,  //操作者代码 4
  
  0x00010000,   //正向有功总, 4
  0x00020000,   //反向有功总, 4
  0x00050000,   //一象限无功
  0x00060000,   //二象限无功
  0x00070000,   //三象限无功
  0x00080000,   //四象限无功
  
  0x00150000,   //A相正向有功总, 4
  0x00160000,   //A相反向有功总, 4
  0x00190000,   //A相一象限无功
  0x001A0000,   //A相二象限无功
  0x001B0000,   //A相三象限无功
  0x001C0000,   //A相四象限无功
  
  0x00290000,   //B相正向有功总
  0x002A0000,   //B相反向有功总
  0x002D0000,   //B相一象限无功
  0x002E0000,   //B相二象限无功
  0x002F0000,   //B相三象限无功
  0x00300000,   //B相四象限无功
  
  0x003D0000,   //C相正向有功总
  0x003E0000,   //C相反向有功总
  0x00410000,   //C相一象限无功
  0x00420000,   //C相二象限无功
  0x00430000,   //C相三象限无功
  0x00440000,   //C相四象限无功
  };

CONST PROTO_DI CONST_PDI14[]=
{_PDI_CUR_TIME, //发生时刻, 6
  _PDI_OPERATOR_ID,  //操作者代码 4
  
  0x01010000,   //正向有功总最大需量及发生时间
  0x01020000,   //反向有功总最大需量及发生时间
  0x01050000,   //一象限无功最大需量及发生时间
  0x01060000,   //二象限无功最大需量及发生时间
  0x01070000,   //三象限无功最大需量及发生时间
  0x01080000,   //四象限无功最大需量及发生时间
  
  0x01150000,   //A相正向有功总最大需量及发生时间
  0x01160000,   //A相反向有功总最大需量及发生时间
  0x01190000,   //A相一象限无功最大需量及发生时间
  0x011A0000,   //A相二象限无功最大需量及发生时间
  0x011B0000,   //A相三象限无功最大需量及发生时间
  0x011C0000,   //A相四象限无功最大需量及发生时间
  
  0x01290000,   //B相正向有功总最大需量及发生时间
  0x012A0000,   //B相反向有功总最大需量及发生时间
  0x012D0000,   //B相一象限无功最大需量及发生时间
  0x012E0000,   //B相二象限无功最大需量及发生时间
  0x012F0000,   //B相三象限无功最大需量及发生时间
  0x01300000,   //B相四象限无功最大需量及发生时间
  
  0x013D0000,   //C相正向有功总最大需量及发生时间
  0x013E0000,   //C相反向有功总最大需量及发生时间
  0x01410000,   //C相一象限无功最大需量及发生时间
  0x01420000,   //C相二象限无功最大需量及发生时间
  0x01430000,   //C相三象限无功最大需量及发生时间
  0x01440000,   //C相四象限无功最大需量及发生时间
  };

CONST PROTO_DI CONST_PDI15[]=
{_PDI_CUR_TIME, //发生时刻6 
  _PDI_OPERATOR_ID,  //操作者代码 4
  _PDI_CLR_EVENT_DI,  //事件清零数据标识码 4
  };


CONST PROTO_DI CONST_PDI16[]=
{
    _PDI_OPERATOR_ID,  //操作者代码 4
    _PDI_ADJ_BEF_TIME, //校时前时间 6
    _PDI_ADJ_AFT_TIME, //校时后时间 ，即当前时间
  };

CONST PROTO_DI CONST_PDI17[]={
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    
    0x04010001, //第一套时段表 42*8
    0x04010002, 
    0x04010003, 
    0x04010004, 
    0x04010005, 
    0x04010006, 
    0x04010007, 
    0x04010008, 
    
    0x04020001, //第二套时段表 42*8
    0x04020002, 
    0x04020003, 
    0x04020004, 
    0x04020005, 
    0x04020006, 
    0x04020007, 
    0x04020008, 
  };

CONST PROTO_DI CONST_PDI18[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    
    0x04010000, //第一套年时区表 14*3
    0x04020000, //第二套年时区表 14*3
  };

CONST PROTO_DI CONST_PDI19[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x04000802,  //周休日采用的日时段表号 1
  };

CONST PROTO_DI CONST_PDI20[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x040300FF,  //1-254个节假日
  };

CONST PROTO_DI CONST_PDI21[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x04000601 //有功组合方式 1
  };

CONST PROTO_DI CONST_PDI22[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x04000602 //无功组合方式 1
  };

CONST PROTO_DI CONST_PDI23[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x04000603,  //无功组合方式 2
  };

CONST PROTO_DI CONST_PDI24[]=
{
    _PDI_CUR_TIME, //发生时刻 6
    _PDI_OPERATOR_ID,  //操作者代码 4 
    0x04000B01,  //第一结算日
    0x04000B02,  //第二结算日
    0x04000B03,  //第三结算日
  };

CONST PROTO_DI CONST_PDI25[]=
{_PDI_CUR_TIME, //发生时刻, 6
  _PDI_CUR_TIME,  //结束时刻 6
  
  0x00010000,   //正向有功总, 发生前电能数据
  0x00020000,   //反向有功总
  0x00050000,   //一象限无功
  0x00060000,   //二象限无功
  0x00070000,   //三象限无功
  0x00080000,   //四象限无功
  
  0x00010000,   //正向有功总, 发生后电能数据
  0x00020000,   //反向有功总
  0x00050000,   //一象限无功
  0x00060000,   //二象限无功
  0x00070000,   //三象限无功
  0x00080000,   //四象限无功
  };

CONST PROTO_DI CONST_PDI26[]=
{_PDI_CUR_TIME0, //发生时刻
  0x0001FF00,//正向有功电能
  0x0002FF00,//反向有功电能
  0x0003FF00, //当前组合无功1电能
  0x0004FF00, //当前组合无功2电能
  0x0005FF00, //当前一象限无功电能
  0x0006FF00, //当前二象限无功电能
  0x0007FF00, //当前三象限无功电能
  0x0008FF00, //当前四象限无功电能
  0x0101FF00, //正向有功需量及其发生时间
  0x0102FF00, //反向有功需量及其发生时间
  0x0203FF00, //有功功率
  0x0204FF00  //无功功率
  };

CONST PROTO_DI CONST_PDI27[]=
{_PDI_CUR_TIME, //发生时刻，6字节
  _PDI_CUR_TIME, //结束时刻
  0x0E010301,//正向有功需量
  0x0E010302,//反向有功需量
  };

CONST PROTO_DI CONST_PDI28[]=
{_PDI_CUR_TIME, //发生时刻，6字节
  0x0E010301,//正向有功需量
  0x0E010302,//反向有功需量
  };

CONST PROTO_DI CONST_PDI29[]=
{_PDI_PD_TIME, //发生时刻
  _PDI_PO_TIME,  //结束时刻
  };

CONST PROTO_DI CONST_PDI30[]=
{_PDI_CUR_TIME, //发生时刻, 6       	 （上1次）跳闸发生时刻                      
   _PDI_OPERATOR_ID,    //   4                             // （上1次）跳闸操作者代码     
   0x00010000,   //正向有功总, 4                     （上1次）跳闸时正向有功总电能    
   0x00020000,   //反向有功总, 4                     （上1次）跳闸时反向有功总电能   
   
   0x00050000,        //  4                                     //  （上1次）跳闸时第一象限无功总电能
   0x00060000,       //   4                                      //（上1次）跳闸时第二象限无功总电能
   0x00070000,       //   4                                         //（上1次）跳闸时第三象限无功总电能
   0x00080000         //  4                                      //（上1次）跳闸时第四象限无功总电能
                                                                                                      
  };

CONST PROTO_DI CONST_PDI31[]=
{_PDI_CUR_TIME0, //发生时刻,5字节,软时钟时间
  _PDI_RTC_ERR_TIME,   //正向有功总, 发生前电能数据
  _PDI_NULL_1BYTE
  };

CONST PROTO_DI CONST_PDI32[]=
{_PDI_CUR_TIME, //6字节
  };

CONST PROTO_DI CONST_PDI33[]=
{
  _PDI_CUR_TIME0, //发生时刻
  0x00010000,//正向有功电能
  0x00020000,//反向有功电能
  };

CONST PROTO_DI CONST_PDI34[]=
{_PDI_CUR_TIME0, //发生时刻
  0x0001FF00,//设置后正向有功电能
  0x0001FF00,//设置前正向有功电能
  };

CONST PROTO_DI CONST_PDI35[]=
{_PDI_CUR_TIME0, //发生时刻
  _PDI_TOTAL_PREPAID_ENERGY_COUNTS,//购电总次数
  _PDI_CUR_PREPAID_ENERGY, //购电量
  _PDI_CUR_PREPAID_BEF_ENERGY, //购电前剩余电量
  0x00900100, //购电后剩余电量
  _PDI_TOTAL_PREPAID_ENERGY, //累计购电量
  };

CONST PROTO_DI CONST_PDI36[]=
{_PDI_CUR_TIME0, //发生时刻
  _PDI_TOTAL_PREPAID_MONEY_COUNTS,//购电总次数
  _PDI_CUR_PREPAID_MONEY, //购电金额
  _PDI_CUR_PREPAID_BEF_MONEY, //购电前剩余金额
  0x00900200, //购电后剩余金额
  _PDI_TOTAL_PREPAID_MONEY, //累计购金额
  };

CONST PROTO_DI CONST_PDI37[]=
{_PDI_CUR_TIME, //发生时刻, 6       （上1次）总功率因数超下限发生时刻                
  0x00010000,   //正向有功总, 4                   （上1次）总功率因数超下限发生时刻正向有功总电能  
  0x00020000,   //反向有功总, 4                   （上1次）总功率因数超下限发生时刻反向有功总电能  
  0x00030000,   //组合无功1, 4                     （上1次）总功率因数超下限发生时刻组合无功1总电能 
  
   0x00040000,   //组合无功2, 4                   （上1次）总功率因数超下限发生时刻组合无功2总电能 
    _PDI_CUR_TIME,//         6                    （上1次）总功率因数超下限结束时刻                             
   0x00010000,   //正向有功总, 4                 （上1次）总功率因数超下限结束时刻正向有功总电能  
   0x00020000,   //反向有功总, 4                （上1次）总功率因数超下限结束时刻反向有功总电能  
   //B           8
   0x00030000,   //组合无功1, 4                      （上1次）总功率因数超下限结束时刻组合无功1总电能          
   0x00040000   //组合无功2, 4                      （上1次）总功率因数超下限结束时刻组合无功2总电能    
                                                
  };

CONST PROTO_DI CONST_PDI38[]=
{ _PDI_CUR_TIME, //发生时刻6       （上1次）电流不平衡发生时刻                                                                  
  0x00010000,   //正向有功总    4                 （上1次）电流不平衡发生时刻正向有功总电能  
  0x00020000,   //反向有功总    4                 （上1次）电流不平衡发生时刻反向有功总电能  
  0x00030000,   //组合无功1    4                  （上1次）电流不平衡发生时刻组合无功1总电能 
  
  0x00040000,   //组合无功2    4                  （上1次）电流不平衡发生时刻组合无功2总电能 
  0x00150000,   //A相正向有功总  4                （上1次）电流不平衡发生时刻A相正向有功电能 
  0x00160000,   //A相反向有功总  4                （上1次）电流不平衡发生时刻A相反向有功电能 
  0x00170000,   //A相组合无功1    4               （上1次）电流不平衡发生时刻A相组合无功1电能
  //B        32 
  0x00180000,   //A相组合无功2    4               （上1次）电流不平衡发生时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4               （上1次）电流不平衡发生时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总    4              （上1次）电流不平衡发生时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1     4              （上1次）电流不平衡发生时刻B相组合无功1电能
  
  0x002C0000,   //B相组合无功2     4              （上1次）电流不平衡发生时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总    4              （上1次）电流不平衡发生时刻C相正向有功电能 
  0x003E0000,   //C相反向有功总   4               （上1次）电流不平衡发生时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1    4               （上1次）电流不平衡发生时刻C相组合无功1电能
  //C        32
  0x00400000,   //C相组合无功2    4               （上1次）电流不平衡发生时刻C相组合无功2电能
  _PDI_CURR_MAX_UNBALANCE,  //最大电压不平衡率 2  （上1次）电流不平衡最大不平衡率                 
  _PDI_CUR_TIME, //结束时刻  6                     （上1次）电流不平衡结束时刻    
  0x00010000,   //正向有功总    4        	 (上1次）电流不平衡结束时刻正向有功总电能    
  0x00020000,   //反向有功总     4                （上1次）电流不平衡结束时刻反向有功总电能  
  0x00030000,   //组合无功1     4                 （上1次）电流不平衡结束时刻组合无功1总电能 
  0x00040000,   //组合无功2     4                 （上1次）电流不平衡结束时刻组合无功2总电能 
  0x00150000,   //A相正向有功总  4                （上1次）电流不平衡结束时刻A相正向有功电能 
  //D       32    
  0x00160000,   //A相反向有功总    4              （上1次）电流不平衡结束时刻A相反向有功电能 
  0x00170000,   //A相组合无功1   4                （上1次）电流不平衡结束时刻A相组合无功1电能
  0x00180000,   //A相组合无功2    4               （上1次）电流不平衡结束时刻A相组合无功2电能
  0x00290000,   //B相正向有功总   4               （上1次）电流不平衡结束时刻B相正向有功电能 
  0x002A0000,   //B相反向有功总   4               （上1次）电流不平衡结束时刻B相反向有功电能 
  0x002B0000,   //B相组合无功1    4               （上1次）电流不平衡结束时刻B相组合无功1电能
  0x002C0000,   //B相组合无功2    4               （上1次）电流不平衡结束时刻B相组合无功2电能
  0x003D0000,   //C相正向有功总   4               （上1次）电流不平衡结束时刻C相正向有功电能 
  //E       12
  0x003E0000,   //C相反向有功总   4               （上1次）电流不平衡结束时刻C相反向有功电能 
  0x003F0000,   //C相组合无功1    4               （上1次）电流不平衡结束时刻C相组合无功1电能
  0x00400000,   //C相组合无功2    4               （上1次）电流不平衡结束时刻C相组合无功2电能
                                                                                          
  };

CONST S_Event_DI Event_DI[] =
{
   //0--失压、欠压、断相
                       //a          b           c            d           e   f    g
  {/*.Occur_Mask  = */ {0xFF,      0xFF,        0xFF,        0xFF,      0x0F,0x00,0x00}, 
  /*.End_Mask  = */    {0x00,      0x00,        0x00,        0x00,      0xFF, 0xFF, 0x1F}, 
  /*.PDIff_Mask  = */  {0x00,      0x00,       0x00,        0x00,      0x0F, 0x00, 0x00}, 
  /*.Data_Num  = */ 48+5, 
  /*data len*/195+1,
 
  /*.PDI   = */CONST_PDI0},
  
  //1--全失压
  {/*.Occur_Mask  = */ {0x03, 0x00,  0x00,  0x00,  0x00 }, 
  /*.End_Mask  = */ {0x04,  0x00,  0x00,  0x00,  0x00,  }, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 15 + 1, 
  /*.PDI   = */CONST_PDI1}, 
  
  //2--失流、过流、断流
   //                    A       B      C      D     E      F      G
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0xFF,  0xFF,  0x00,  0x00,  0x00},  
  /*.End_Mask  = */    {0x00,  0x00,  0x00,  0x00,  0xFF,  0xFF,  0x01},     
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00},  
  /*.Data_Num  = */ 49,                                     
  /*.Data_Len  = */ 179+1,  
  
  //A        34
  /*.PDI   = */CONST_PDI2}, 
  
  //3--辅助电源失电、电池欠压
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x02,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 2, 
  /*.Data_Len  = */12 + 1, 
  /*.PDI   = */CONST_PDI3}, 
  
  //4--电压逆相序、电流逆相序、潮流反向、过载
   //                     A      B      C       D    E
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0x01,  0x00,  0x00},                    
  /*.End_Mask  = */    {0x00,  0x00,  0xFE,  0xFF,  0x03},                       
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00},                    
  /*.Data_Num  = */ 34,                                                       
  /*.Data_Len  = */ 140+1,   
     
    //A        34                                     
  /*.PDI   = */CONST_PDI4}, 
  
  //5--电压不平衡
   //                   A      B      C      D       E
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0x03,  0x00,  0x00},                    
  /*.End_Mask  = */    {0x00,  0x00,  0xFC,  0xFF,  0x07},                       
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00},                    
  /*.Data_Num  = */ 35,                                                       
  /*.Data_Len  = */ 143+ 1,                                                   
                                     
  //A         34                          
   /*.PDI   = */CONST_PDI5},
  
  //6--正向有功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI6}, 
  
  //7--反向有功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI7}, 
  
  //8--第一象限无功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI8}, 
  
  //9--第二象限无功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI9}, 
  
  //10--第三象限无功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI10}, 
  
  //11--第四象限无功需量超限
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x0E,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x0C,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 20 + 1, 
  /*.PDI   = */CONST_PDI11}, 
  
  //12--编程记录
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 50 + 1, 
  /*.PDI   = */CONST_PDI12}, 
  
  //13--电表清0
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0xFF,  0x03,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 26, 
  /*.Data_Len  = */ 106 + 1, 
  /*.PDI   = */CONST_PDI13}, 
  
  //14--需量清0
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0xFF,  0x03,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 26, 
  /*.Data_Len  = */ 202 + 1, 
  /*.PDI   = */CONST_PDI14}, 
  
  //15--事件清0
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 14 + 1, 
  /*.PDI   = */CONST_PDI15}, 
  
  //16--校时
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 16 + 1, 
  /*.PDI   = */CONST_PDI16}, 
  
  //17--时段表编程
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0x03,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 18, 
  /*.Data_Len  = */ 682 + 1, 
  /*.PDI   = */CONST_PDI17}, 
  
  //18--时区表编程
  {/*.Occur_Mask  = */ {0x0F,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 94 + 1, 
  /*.PDI   = */CONST_PDI18}, 
  
  //19--周休日编程
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 11 + 1, 
  /*.PDI   = */CONST_PDI19}, 
  
  //20--节假日编程
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ MAX_YEAR_HOLIDAYS*4 + 10 + 1, 
  /*.PDI   = */CONST_PDI20}, 
  
  
  //21--有功组合方式
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 11 + 1, 
  /*.PDI   = */CONST_PDI21}, 
  
  //22--无功组合方式1
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 11 + 1, 
  /*.PDI   = */CONST_PDI22}, 
  
  //23--无功组合方式2
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 11 + 1, 
  /*.PDI   = */CONST_PDI23}, 
  
  //24--结算日编程
  {/*.Occur_Mask  = */ {0x01F,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 5, 
  /*.Data_Len  = */ 16 + 1, 
  /*.PDI   = */CONST_PDI24}, 
  
  //25--开表盖、开端钮
  {/*.Occur_Mask  = */ {0xFD,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x02,  0x3F,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 14, 
  /*.Data_Len  = */ 60 + 1, 
  /*.PDI   = */CONST_PDI25}, 
  
  //26--冻结数据、时区表切换、时段表切换
  {/*.Occur_Mask  = */ {0xFF,  0x1F,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 13, 
  /*.Data_Len  = */ FREEZE_DATA_MAX_LEN + 1, 
  /*.PDI   = */CONST_PDI26},
  
  //27--超需量报警
  {/*.Occur_Mask  = */ {0x0D,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x02,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 4, 
  /*.Data_Len  = */ 18 + 1, 
  /*.PDI   = */CONST_PDI27},  
//-------------------------------------------
  //28--超需量跳闸
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 12 + 1, 
  /*.PDI   = */CONST_PDI28}, 
  
  //29--掉电
  {/*.Occur_Mask  = */ {0x03,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 2, 
  /*.Data_Len  = */12 + 1, 
  /*.PDI   = */CONST_PDI29},  
  
  //30--拉闸合闸
  {/*.Occur_Mask  = */{0xFF,  0x00,  0x00,  0x00,  0x00},  
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00},     
  /*.PDIff_Mask  = */{0x00,  0x00,  0x00,  0x00,  0x00},  
  /*.Data_Num  = */8,                                     
  /*.Data_Len  = */34+1,  
   //A           34                             
  /*.PDI   = */CONST_PDI30},   
  
  //31--上电时钟乱和运行时钟乱
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */11 + 1, 
  /*.PDI   = */CONST_PDI31}, 
  
  //32--复位
  {/*.Occur_Mask  = */ {0x01,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 1, 
  /*.Data_Len  = */6 + 1, 
  /*.PDI   = */CONST_PDI32}, 
  
  //33--整点冻结
  {/*.Occur_Mask  = */ {0x07,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 13 + 1, 
  /*.PDI   = */CONST_PDI33},  
    
  //34--设置初始电量
  {/*.Occur_Mask  = */ {0x05,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x02,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 3, 
  /*.Data_Len  = */ 36 + 36 + 5 + 1, 
  /*.PDI   = */CONST_PDI34},     
  
  //35--电量型购电
  {/*.Occur_Mask  = */ {0x3F,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 6, 
  /*.Data_Len  = */ 23 + 1, 
  /*.PDI   = */CONST_PDI35}, 
  
  //36--电费型购电
  {/*.Occur_Mask  = */ {0x3F,  0x00,  0x00,  0x00,  0x00}, 
  /*.End_Mask  = */ {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00}, 
  /*.Data_Num  = */ 6, 
  /*.Data_Len  = */ 23 + 1, 
  /*.PDI   = */CONST_PDI36},
 
    //37--  /*总功率因数超下限*/   
    //                   A      B  
  {/*.Occur_Mask  = */ {0x1F,  0x00,  0x00,  0x00,  0x00},                             
  /*.End_Mask  = */    {0xE0,  0x03,  0x00,  0x00,  0x00},                         
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00},                               
  /*.Data_Num  = */ 10,                                                              
  /*.Data_Len  = */ 44 +1,                                                       
  //A             36                                                                                      
  /*.PDI   = */CONST_PDI37},
  
  //38--电流不平衡
   //                   A      B      C      D       E
  {/*.Occur_Mask  = */ {0xFF,  0xFF,  0x03,  0x00,  0x00},                    
  /*.End_Mask  = */    {0x00,  0x00,  0xFC,  0xFF,  0x07},                       
  /*.PDIff_Mask  = */  {0x00,  0x00,  0x00,  0x00,  0x00},                    
  /*.Data_Num  = */ 35,                                                       
  /*.Data_Len  = */ 143+ 1,                                                   
                                     
  //A         34                          
   /*.PDI   = */CONST_PDI38},  
};

//每种事件的分次事件记录
CONST S_Event_Separate_Data_Info Event_Separate_Data_Info[] =
{
#if LOSS_VOL_NUM > 0
  //A相失压----需要PUCK判断事件起始和结束
  {INIT(Event_ID, ID_EVENT_A_LOSS_VOLT),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x10010100),
  ES_DI(0x10010101),
  INIT(Storage_Num, LOSS_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
  //B相失压
  {INIT(Event_ID, ID_EVENT_B_LOSS_VOLT),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x10020100),
  ES_DI(0x10020101),
  INIT(Storage_Num, LOSS_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
  //C相失压
  {INIT(Event_ID, ID_EVENT_C_LOSS_VOLT),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x10030100),
  ES_DI(0x10030101),
  INIT(Storage_Num, LOSS_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
  
  //A相欠压
  {INIT(Event_ID, ID_EVENT_A_VOLT_LESS),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x11010100),
  ES_DI(0x11010101),
  INIT(Storage_Num, LOW_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
  //B相欠压
  {INIT(Event_ID, ID_EVENT_B_VOLT_LESS),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x11020100),
  ES_DI(0x11020101),
  INIT(Storage_Num, LOW_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
  //C相欠压
  {INIT(Event_ID, ID_EVENT_C_VOLT_LESS),
  //INIT(Property, 0),
  INIT(pData, &Event_DI[0]),
  ES_DI(0x11030100),
  ES_DI(0x11030101),
  INIT(Storage_Num, LOW_VOL_NUM),
  INIT(Clr_Flag, 1)}, 
#endif

#if OVER_VOL_NUM > 0
//A相过压---需要PUCK判断事件其实和结束
{INIT(Event_ID, ID_EVENT_A_VOLT_OVERLOAD),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x12010100),
ES_DI(0x12010101),
INIT(Storage_Num, OVER_VOL_NUM),
INIT(Clr_Flag, 1)}, 
//B相过压
{INIT(Event_ID, ID_EVENT_B_VOLT_OVERLOAD),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x12020100),
ES_DI(0x12020101),
INIT(Storage_Num, OVER_VOL_NUM),
INIT(Clr_Flag, 1)}, 
//C相过压
{INIT(Event_ID, ID_EVENT_C_VOLT_OVERLOAD),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x12030100),
ES_DI(0x12030101),
INIT(Storage_Num, OVER_VOL_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if BREAK_VOL_NUM > 0
//A相断相---需要PUCK判断事件起始和结束
{INIT(Event_ID, ID_EVENT_A_LOSS_PARSE),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x13010100),
ES_DI(0x13010101),
INIT(Storage_Num, BREAK_VOL_NUM),
INIT(Clr_Flag, 1)}, 
//B相断相
{INIT(Event_ID, ID_EVENT_B_LOSS_PARSE),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x13020100),
ES_DI(0x13020101),
INIT(Storage_Num, BREAK_VOL_NUM),
INIT(Clr_Flag, 1)}, 
//C相断相
{INIT(Event_ID, ID_EVENT_C_LOSS_PARSE),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x13030100),
ES_DI(0x13030101),
INIT(Storage_Num, BREAK_VOL_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if ALL_LOSS_VOL_NUM > 0
//全失压---PUCK判断
{INIT(Event_ID, ID_EVENT_ALL_LOSS_VOLT),
//INIT(Property, 0),
INIT(pData, &Event_DI[1]),
ES_DI(0x03050000),
ES_DI(0x03050001),
INIT(Storage_Num, ALL_LOSS_VOL_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if AUX_POWER_DOWN_NUM > 0
//辅助电源失电----PUCK处理,暂无?
{INIT(Event_ID, ID_EVENT_AUX_POWER),
//INIT(Property, 0),
INIT(pData, &Event_DI[3]),
ES_DI(0x03060000),
ES_DI(0x03060001),
INIT(Storage_Num, AUX_POWER_DOWN_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if VOL_REV_SEQ_NUM > 0
//电压逆相序----PUCK判断起始和结束
{INIT(Event_ID, ID_EVENT_VOLT_NEG_SEQ),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x14000100),
ES_DI(0x14000101),
INIT(Storage_Num, VOL_REV_SEQ_NUM),
INIT(Clr_Flag, 1)},
#endif

#if CUR_REV_SEQ_NUM > 0
//电流逆相序----PUCK判断起始和结束
{INIT(Event_ID, ID_EVENT_CUR_NEG_SEQ),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x15000100),
ES_DI(0x15000101),
INIT(Storage_Num, CUR_REV_SEQ_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if VOL_UNBALANCE_NUM > 0
//电压不平衡-----PUCK判断起始和结束
{INIT(Event_ID, ID_EVENT_VOLT_NO_EVEN),
//INIT(Property, 0),
INIT(pData, &Event_DI[5]),
ES_DI(0x16000100),
ES_DI(0x16000101),
INIT(Storage_Num, VOL_UNBALANCE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if CUR_UNBALANCE_NUM > 0
//电流不平衡----PUCK判断起始和结束，暂无?
{INIT(Event_ID, ID_EVENT_CURR_NO_EVEN),
//INIT(Property, 0),
INIT(pData, &Event_DI[38]),
ES_DI(0x17000100),
ES_DI(0x17000101),
INIT(Storage_Num, CUR_UNBALANCE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if LOSS_CUR_NUM > 0
//A相失流----PUCk判断起始和结束
{INIT(Event_ID, ID_EVENT_A_LOSS_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x18010100),
ES_DI(0x18010101),
INIT(Storage_Num, LOSS_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//B相失流
{INIT(Event_ID, ID_EVENT_B_LOSS_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x18020100),
ES_DI(0x18020101),
INIT(Storage_Num, LOSS_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//C相失流
{INIT(Event_ID, ID_EVENT_C_LOSS_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x18030100),
ES_DI(0x18030101),
INIT(Storage_Num, LOSS_CUR_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if OVER_CUR_NUM > 0
//A相过流
{INIT(Event_ID, ID_EVENT_A_OVER_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x19010100),
ES_DI(0x19010101),
INIT(Storage_Num, OVER_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//B相过流
{INIT(Event_ID, ID_EVENT_B_OVER_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x19020100),
ES_DI(0x19020101),
INIT(Storage_Num, OVER_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//C相过流
{INIT(Event_ID, ID_EVENT_C_OVER_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x19030100),
ES_DI(0x19030101),
INIT(Storage_Num, OVER_CUR_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if BREAK_CUR_NUM > 0
//A相断流
{INIT(Event_ID, ID_EVENT_A_CUT_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x1A010100),
ES_DI(0x1A010101),
INIT(Storage_Num, BREAK_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//B相断流
{INIT(Event_ID, ID_EVENT_B_CUT_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x1A020100),
ES_DI(0x1A020101),
INIT(Storage_Num, BREAK_CUR_NUM),
INIT(Clr_Flag, 1)}, 
//C相断流
{INIT(Event_ID, ID_EVENT_C_CUT_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[2]),
ES_DI(0x1A030100),
ES_DI(0x1A030101),
INIT(Storage_Num, BREAK_CUR_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if TREND_REVERSE_NUM > 0
//A相潮流反向
{INIT(Event_ID, ID_EVENT_A_NEG_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1B010100),
ES_DI(0x1B010101),
INIT(Storage_Num, TREND_REVERSE_NUM),
INIT(Clr_Flag, 1)}, 
//B相潮流反向
{INIT(Event_ID, ID_EVENT_B_NEG_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1B020100),
ES_DI(0x1B020101),
INIT(Storage_Num, TREND_REVERSE_NUM),
INIT(Clr_Flag, 1)}, 
//C相潮流反向
{INIT(Event_ID, ID_EVENT_C_NEG_CURR),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1B030100),
ES_DI(0x1B030101),
INIT(Storage_Num, TREND_REVERSE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if OVER_LOAD_NUM > 0
//A相过载
{INIT(Event_ID, ID_EVENT_A_POWER_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1C010100),
ES_DI(0x1C010101),
INIT(Storage_Num, OVER_LOAD_NUM),
INIT(Clr_Flag, 1)}, 
//B相过载
{INIT(Event_ID, ID_EVENT_B_POWER_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1C020100),
ES_DI(0x1C020101),
INIT(Storage_Num, OVER_LOAD_NUM),
INIT(Clr_Flag, 1)}, 
//C相过载
{INIT(Event_ID, ID_EVENT_C_POWER_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[4]),
ES_DI(0x1C030100),
ES_DI(0x1C030101),
INIT(Storage_Num, OVER_LOAD_NUM),
INIT(Clr_Flag, 1)}, 
#endif


//拉闸--欠费和命令
#if RELAY_OFF_NUM > 0
{INIT(Event_ID, ID_EVENT_RELAY_OFF),
//INIT(Property, 0),
INIT(pData, &Event_DI[30]),
ES_DI(0x1D000100),
ES_DI(0x1D000101),
INIT(Storage_Num, RELAY_OFF_NUM),
INIT(Clr_Flag, 1)},
#endif

//合闸--欠费和命令
#if RELAY_ON_NUM > 0
{INIT(Event_ID, ID_EVENT_RELAY_ON),
//INIT(Property, 0),
INIT(pData, &Event_DI[30]),
ES_DI(0x1E000100),
ES_DI(0x1E000101),
INIT(Storage_Num, RELAY_ON_NUM),
INIT(Clr_Flag, 1)},
#endif

//总功率因素低
#if FACTOR_LOW_NUM > 0
{INIT(Event_ID, ID_EVENT_ALL_FACTOR_LOW),
//INIT(Property, 0),
INIT(pData, &Event_DI[37]),
ES_DI(0x1F000100),
ES_DI(0x1F000101),
INIT(Storage_Num, RELAY_ON_NUM),
INIT(Clr_Flag, 1)},
#endif
/*
//电压统计--实际上不是作为事件记录处理，定义在此，只是为了清事件时也能统一清除该数据
{INIT(Event_ID, ID_VOL_STAT),
//INIT(Property, 0),
INIT(pData, &Event_DI[0]),
ES_DI(0x03110000),
ES_DI(0x03110001),
INIT(Storage_Num, MAX_VOLSTAT_SETTLE_NUM),
INIT(Clr_Flag, 1)}, 
*/
#if POWER_DOWN_NUM > 0
//掉电
{INIT(Event_ID, ID_EVENT_POWER_OFF),
//INIT(Property, 0),
INIT(pData, &Event_DI[29]),
ES_DI(0x03110000),
ES_DI(0x03110001),
INIT(Storage_Num, POWER_DOWN_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if POS_ACT_DEMAND_EXCEED_NUM > 0
//正向有功需量超限
{INIT(Event_ID, ID_EVENT_POS_ACT_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[6]),
ES_DI(0x03120100),
ES_DI(0x03120101),
INIT(Storage_Num, POS_ACT_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if NEG_ACT_DEMAND_EXCEED_NUM > 0
//反向有功需量超限
{INIT(Event_ID, ID_EVENT_NEG_ACT_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[7]),
ES_DI(0x03120200),
ES_DI(0x03120201),
INIT(Storage_Num, NEG_ACT_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if REA_DEMAND_EXCEED_NUM > 0
//第一象限无功需量超限
{INIT(Event_ID, ID_EVENT_Q1_REAC_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[8]),
ES_DI(0x03120300),
ES_DI(0x03120301),
INIT(Storage_Num, REA_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
//第二象限无功需量超限
{INIT(Event_ID, ID_EVENT_Q2_REAC_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[9]),
ES_DI(0x03120400),
ES_DI(0x03120401),
INIT(Storage_Num, REA_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
//第三象限无功需量超限
{INIT(Event_ID, ID_EVENT_Q3_REAC_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[10]),
ES_DI(0x03120500),
ES_DI(0x03120501),
INIT(Storage_Num, REA_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
//第四象限无功需量超限
{INIT(Event_ID, ID_EVENT_Q4_REAC_DEMAND_EXCEED),
//INIT(Property, 0),
INIT(pData, &Event_DI[11]),
ES_DI(0x03120600),
ES_DI(0x03120601),
INIT(Storage_Num, REA_DEMAND_EXCEED_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if PROG_NUM > 0
//编程记录
{INIT(Event_ID, ID_EVENT_PROG),
//INIT(Property, 0),
INIT(pData, &Event_DI[12]),
ES_DI(0x03300000),
ES_DI(0x03300001),
INIT(Storage_Num, PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if CLEAR_METER_NUM > 0
//电表清零记录
{INIT(Event_ID, ID_EVENT_CLR_ALL_DATA),
//INIT(Property, 0),
INIT(pData, &Event_DI[13]),
ES_DI(0x03300100),
ES_DI(0x03300101),
INIT(Storage_Num, CLEAR_METER_NUM),
INIT(Clr_Flag, 0)}, 
#endif

#if CLEAR_DEMAND_NUM > 0
//需量清零记录
{INIT(Event_ID, ID_EVENT_CLR_DEMAND_COM),
//INIT(Property, 0),
INIT(pData, &Event_DI[14]),
ES_DI(0x03300200),
ES_DI(0x03300201),
INIT(Storage_Num, CLEAR_DEMAND_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if CLEAR_EVENT_NUM > 0
//事件清零记录--清过程就是清事件
{INIT(Event_ID, ID_EVENT_CLR_PROCESS),
//INIT(Property, 0),
INIT(pData, &Event_DI[15]),
ES_DI(0x03300300),
ES_DI(0x03300301),
INIT(Storage_Num, CLEAR_EVENT_NUM),
INIT(Clr_Flag, 0)},
#endif

#if ADJ_TIME_NUM > 0
//校时记录
{INIT(Event_ID, ID_EVENT_ADJUST_TIME),
//INIT(Property, 0),
INIT(pData, &Event_DI[16]),
ES_DI(0x03300400),
ES_DI(0x03300401),
INIT(Storage_Num, ADJ_TIME_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if DATE_TABLE_PROG_NUM > 0
//时段表编程
{INIT(Event_ID, ID_EVENT_DATE),
//INIT(Property, 0),
INIT(pData, &Event_DI[17]),
ES_DI(0x03300500),
ES_DI(0x03300501),
INIT(Storage_Num, DATE_TABLE_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if YEAR_TABLE_PROG_NUM > 0
//时区表编程
{INIT(Event_ID, ID_EVENT_YEAR),
//INIT(Property, 0),
INIT(pData, &Event_DI[18]),
ES_DI(0x03300600),
ES_DI(0x03300601),
INIT(Storage_Num, YEAR_TABLE_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if WEEK_REST_PROG_NUM > 0
//周休日编程
{INIT(Event_ID, ID_EVENT_WEEK),
//INIT(Property, 0),
INIT(pData, &Event_DI[19]),
ES_DI(0x03300700),
ES_DI(0x03300701),
INIT(Storage_Num, WEEK_REST_PROG_NUM),
INIT(Clr_Flag, 1)},
#endif

#if HOLIDAY_PROG_NUM > 0
//节假日编程
{INIT(Event_ID, ID_EVENT_HOLIDAY),
//INIT(Property, 0),
INIT(pData, &Event_DI[20]),
ES_DI(0x03300800),
ES_DI(0x03300801),
INIT(Storage_Num, HOLIDAY_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if ACTIVE_COMB_PROG_NUM > 0
//有功组合方式编程
{INIT(Event_ID, ID_EVENT_ACPWR),
//INIT(Property, 0),
INIT(pData, &Event_DI[21]),
ES_DI(0x03300900),
ES_DI(0x03300901),
INIT(Storage_Num, ACTIVE_COMB_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if REACTIVE_COMB_PROG_NUM > 0
//无功组合方式1编程
{INIT(Event_ID, ID_EVENT_REACPWR1),
//INIT(Property, 0),
INIT(pData, &Event_DI[22]),
ES_DI(0x03300A00),
ES_DI(0x03300A01),
INIT(Storage_Num, REACTIVE_COMB_PROG_NUM),
INIT(Clr_Flag, 1)},
#endif

#if REACTIVE_COMB_PROG_NUM > 0 
//无功组合方式2编程
{INIT(Event_ID, ID_EVENT_REACPWR2),
//INIT(Property, 0),
INIT(pData, &Event_DI[23]),
ES_DI(0x03300B00),
ES_DI(0x03300B01),
INIT(Storage_Num, REACTIVE_COMB_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if SETTLE_TIME_PROG_NUM > 0
//结算日编程
{INIT(Event_ID, ID_EVENT_SETTLE_DATE),
//INIT(Property, 0),
INIT(pData, &Event_DI[24]),
ES_DI(0x03300C00),
ES_DI(0x03300C01),
INIT(Storage_Num, SETTLE_TIME_PROG_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if OPEN_METER_COVER_NUM > 0
//开表盖--开大盖
{INIT(Event_ID, ID_EVENT_UP_COVER_OPEN),
//INIT(Property, 0),
INIT(pData, &Event_DI[25]),
ES_DI(0x03300D00),
ES_DI(0x03300D01),
INIT(Storage_Num, OPEN_METER_COVER_NUM),
INIT(Clr_Flag, 1)}, 
#endif

#if OPEN_BOTTOM_COVER_NUM > 0
//开端钮盒---开端盖
{INIT(Event_ID, ID_EVENT_DOWN_COVER_OPEN),
//INIT(Property, 0),
INIT(pData, &Event_DI[25]),
ES_DI(0x03300E00),
ES_DI(0x03300E01),
INIT(Storage_Num, OPEN_BOTTOM_COVER_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//低功耗电池欠压
#if LOWPWR_BAT_LOW_NUM > 0
{INIT(Event_ID, ID_EVENT_LOWPWR_BAT_LOW),
//INIT(Property, 0),
INIT(pData, &Event_DI[3]),
ES_DI(0x03410000),
ES_DI(0x03410001),
INIT(Storage_Num, LOWPWR_BAT_LOW_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//时钟电池欠压
#if RTC_BAT_LOW_NUM > 0
{INIT(Event_ID, ID_EVENT_RTC_BAT_LOW),
//INIT(Property, 0),
INIT(pData, &Event_DI[3]),
ES_DI(0x03410100),
ES_DI(0x03410101),
INIT(Storage_Num, RTC_BAT_LOW_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//负空报警（超需量报警）
#if PWR_CTRL_ALARM_NUM > 0
{INIT(Event_ID, ID_EVENT_DEMAND_ALARM),
//INIT(Property, 0),
INIT(pData, &Event_DI[27]),
ES_DI(0x03420000),
ES_DI(0x03420001),
INIT(Storage_Num, PWR_CTRL_ALARM_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//负空跳闸（超需量跳闸）
#if PWR_CTRL_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_DEMAND_SWITCH),
//INIT(Property, 0),
INIT(pData, &Event_DI[28]),
ES_DI(0x03420100),
ES_DI(0x03420101),
INIT(Storage_Num, PWR_CTRL_SWITCH_NUM),
INIT(Clr_Flag, 1)}, 
#endif

///////////////////////////////////////以下是冻结数据，作为事件数据统一处理///////////////
//定时冻结时间
#if PERIOD_FREEZE_NUM > 0
{INIT(Event_ID, ID_EVENT_PERIOD_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)PERIOD_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)PERIOD_FREEZE_TYPE << 16),
INIT(Storage_Num, PERIOD_FREEZE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//瞬时冻结时间
#if INSTANT_FREEZE_NUM > 0
{INIT(Event_ID, ID_EVENT_INSTANT_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)INSTANT_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)INSTANT_FREEZE_TYPE << 16),
INIT(Storage_Num, INSTANT_FREEZE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//时区表切换
#if YEAR_TABLE_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_YEAR_TABLE_SWITCH_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)YEAR_SWITCH_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)YEAR_SWITCH_FREEZE_TYPE << 16),
INIT(Storage_Num, YEAR_TABLE_SWITCH_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//时段表切换
#if DATE_TABLE_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_DATE_TABLE_SWITCH_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)DATE_SWITCH_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)DATE_SWITCH_FREEZE_TYPE << 16),
INIT(Storage_Num, DATE_TABLE_SWITCH_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//两套梯度切换
#if STEP_SCH_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_STEP_SCH_SWITCH_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)STEP_SWITCH_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)STEP_SWITCH_FREEZE_TYPE << 16),
INIT(Storage_Num, STEP_SCH_SWITCH_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//两套分时费率切换
#if RATE_SCH_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_RATE_SCH_SWITCH_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)RATE_SWITCH_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)RATE_SWITCH_FREEZE_TYPE << 16),
INIT(Storage_Num, RATE_SCH_SWITCH_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//日冻结
#if DATE_FREEZE_NUM > 0
{INIT(Event_ID, ID_EVENT_DATE_FREEZ),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)DATE_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)DATE_FREEZE_TYPE << 16),
INIT(Storage_Num, DATE_FREEZE_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//小时冻结,只冻结正向有功和反向有功的总
#if HOUR_FREEZE_0_NUM > 0
{INIT(Event_ID, ID_EVENT_HOUR_FREEZ),
//INIT(Property, 0),
INIT(pData, &Event_DI[33]),
ES_DI(0x05000000) | ((PROTO_DI)HOUR_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)HOUR_FREEZE_TYPE << 16),
INIT(Storage_Num, HOUR_FREEZE_0_NUM),
INIT(Clr_Flag, 1)}, 
#endif 

//电量翻转
#if ENERGY_OVERTRUN_NUM > 0
{INIT(Event_ID, ID_EVENT_ENERGY_OVERTURN_FREEZE),
//INIT(Property, 0),
INIT(pData, &Event_DI[26]),
ES_DI(0x05000000) | ((PROTO_DI)ENG_OVERTURN_FREEZE_TYPE << 16),
ES_DI(0x05000001) | ((PROTO_DI)ENG_OVERTURN_FREEZE_TYPE << 16),
INIT(Storage_Num, ENERGY_OVERTRUN_NUM),
INIT(Clr_Flag, 1)}, 
#endif
//-----------------------------扩充事件记录-----------------
//复位
#if RESET_NUM > 0
{INIT(Event_ID, ID_EVENT_RESET),
//INIT(Property, 0),
INIT(pData, &Event_DI[32]),
ES_DI(0x0E180000),
ES_DI(0x0E180001),
INIT(Storage_Num, RESET_NUM),
INIT(Clr_Flag, 1)}, 
#endif

//运行时钟乱
#if RUN_CLOCK_ERR_NUM > 0
{INIT(Event_ID, ID_EVENT_RTCERR_RUN),
//INIT(Property, 0),
INIT(pData, &Event_DI[31]),
ES_DI(0x0E190000),
ES_DI(0x0E190001),
INIT(Storage_Num, RUN_CLOCK_ERR_NUM),
INIT(Clr_Flag, 1)},
#endif

//上电时钟乱
#if POWER_ON_CLOCK_ERR_NUM > 0
{INIT(Event_ID, ID_EVENT_RTCERR_PWRON),
//INIT(Property, 0),
INIT(pData, &Event_DI[31]),
ES_DI(0x0E1C0000),
ES_DI(0x0E1C0001),
INIT(Storage_Num, POWER_ON_CLOCK_ERR_NUM),
INIT(Clr_Flag, 1)},
#endif
/*
//拉闸
#if REMOTE_RELAY_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_REMOTE_RELAY_OFF),
//INIT(Property, 0),
INIT(pData, &Event_DI[30]),
ES_DI(0x0E1D0000),
ES_DI(0x0E1D0001),
INIT(Storage_Num, REMOTE_RELAY_SWITCH_NUM),
INIT(Clr_Flag, 1)},
#endif


//远程合闸
#if REMOTE_RELAY_SWITCH_NUM > 0
{INIT(Event_ID, ID_EVENT_REMOTE_RELAY_ON),
//INIT(Property, 0),
INIT(pData, &Event_DI[30]),
ES_DI(0x0E1E0000),
ES_DI(0x0E1E0001),
INIT(Storage_Num, REMOTE_RELAY_SWITCH_NUM),
INIT(Clr_Flag, 1)},
#endif
*/

//设置初始电量
#if SET_ENERG_NUM > 0
{INIT(Event_ID, ID_EVENT_SET_ENERG),
//INIT(Property, 0),
INIT(pData, &Event_DI[34]),
ES_DI(0x0E301100),
ES_DI(0x0E301101),
INIT(Storage_Num, SET_ENERG_NUM),
INIT(Clr_Flag, 0)},
#endif

//电量型购电
#if PREPAID_ENERGY_NUM > 0
{INIT(Event_ID, ID_EVENT_PREPAID_ENERGY),
//INIT(Property, 0),
INIT(pData, &Event_DI[35]),
ES_DI(0x03320100),
ES_DI(0x03320101),
INIT(Storage_Num, PREPAID_ENERGY_NUM),
INIT(Clr_Flag, 1)},
#endif

//电量型购电
#if PREPAID_MONEY_NUM > 0
{INIT(Event_ID, ID_EVENT_PREPAID_MONEY),
//INIT(Property, 0),
INIT(pData, &Event_DI[36]),
ES_DI(0x03330100),
ES_DI(0x03330101),
INIT(Storage_Num, PREPAID_MONEY_NUM),
INIT(Clr_Flag, 1)},
#endif

EXTEND_EVENT_SEPARATE
};


//DI表示事件记录的DI
//返回该DI对应的事件在Event_Separate_Data_Info中的索引值
//返回NULL_2BYTES表示没有该DI对应的事件
INT16U Get_Event_Separate_Proto_Index(PROTO_DI PDI)
{
  INT16U i;
  
  TRACE();
  
  for(i = 0; i < S_NUM(Event_Separate_Data_Info); i ++)
  {
    if((PDI & 0x0FFFFF00) == (Event_Separate_Data_Info[i].SDI & 0x0FFFFF00) &&\
      (PDI & 0xFF) >= (Event_Separate_Data_Info[i].SDI & 0xFF) &&\
      ((INT8U)(PDI & 0xFF) - (INT8U)(Event_Separate_Data_Info[i].SDI & 0xFF)) < Event_Separate_Data_Info[i].Storage_Num)  
      return i;
  }
  
  ASSERT_FAILED();
  return NULL_2BYTES;
}

//获取某个事件在事件信息表中的索引值
//Event_ID表示该事件的ID值
INT16U Get_Event_Separate_Data_Index(INT8U Event_ID)
{
  INT16U i;
  
  TRACE();
  
  for(i = 0; i < S_NUM(Event_Separate_Data_Info); i ++)
  {
    if(Event_ID EQ Event_Separate_Data_Info[i].Event_ID)
    {
      return i;
    }
  }
  
  return NULL_2BYTES;
}

//读取事件Event_ID的最近一次事件的事件记录存储DI
STORA_DI Read_Last_Event_SDI(INT8U Event_ID)
{
  INT16U Index, Len;
  STORA_DI SDI;
  INT8U Temp[6];
  
  TRACE();
  
  Index = Get_Event_Separate_Data_Index(Event_ID);//获取事件在Event_Separate_Data_Info中的索引值 
  if(NULL_2BYTES EQ Index)
  {
    ASSERT_FAILED();
    return NULL_STORA_DI;
  }
  
  if(Event_Separate_Data_Info[Index].Storage_Num EQ 1)//只存储一条事件记录
  {
    return Event_Separate_Data_Info[Index].SDI;
  }
  
  Len = Read_Storage_Data(Event_Separate_Data_Info[Index].Last_SDI, Temp, Temp, sizeof(Temp));
  if(!(Len EQ 4)) //没有读取到上次发生事件的记录
  {
    ASSERT_FAILED();
    return Event_Separate_Data_Info[Index].SDI;//返回第一条的存储DI
  }
  
  mem_cpy(&SDI, Temp, sizeof(STORA_DI), &SDI, sizeof(SDI));//读取到的4个字节是上次存储事件的存储DI
  
  if(SDI EQ NULL_EVENT_STORA_DI)//该事件没有发生过
  {
    return NULL_EVENT_STORA_DI;
  }
  
  //判断SDI是否在合理范围内
  if(!(Event_Separate_Data_Info[Index].Storage_Num > 1 && \
    SDI >= Event_Separate_Data_Info[Index].SDI && \
      SDI < Event_Separate_Data_Info[Index].SDI + Event_Separate_Data_Info[Index].Storage_Num))
  {
    ASSERT_FAILED();
    SDI = Event_Separate_Data_Info[Index].SDI;
  }
  
  return SDI;
}

//该函数用来读取上次发生的某事件的记录, 只有Separate_RECORD_EVENT类事件才需要调用该函数
//Event_ID表示事件的ID
//SDI, 最近一条记录的存储DI
//pDst表示目标缓冲区的起始
//pDst_Start和DstLen一起限定pDst和DstLen的范围
//返回值，数据长度，为0表示没有读取到，可能是校验和错误或者是根本没有存储
INT16U Read_Last_Event_Data(INT8U Event_ID, STORA_DI SDI, void* pDst, void* pDst_Start, INT16U DstLen)
{
  INT16U i, Len;
  
  TRACE();
  //SDI = Read_Last_Event_SDI(EVENT_ID);
  ASSERT(SDI != NULL_4BYTES);
  //读取最近发生的一次事件记录
  Len = Read_Storage_Data(SDI, pDst, pDst_Start, DstLen);
  
  //判断数据长度是否正确
  i = Get_Event_Separate_Data_Index(Event_ID);
  //检查返回数据的合法性
  if(!(NULL_2BYTES != i && Event_Separate_Data_Info[i].pData -> Data_Len >= Len))
  {
    ASSERT_FAILED();
    return 0;
  }
  else
  {
    return Len;
  }
}

INT16U Get_Separate_Event_Num()
{
  return S_NUM(Event_Separate_Data_Info);
}

//特殊事件发生处理
INT16U Event_Spec_Separate_Start_Proc(INT8U Event_ID, INT8U Flag)
{
  if(Flag EQ EVENT_REAL)
  {
    if(Event_ID EQ ID_EVENT_A_LOSS_VOLT || Event_ID EQ ID_EVENT_B_LOSS_VOLT || Event_ID EQ ID_EVENT_C_LOSS_VOLT)
    {
      if(Get_Event_Total_Occuring_Singles(ID_EVENT_TOTAL_LOSS_VOL) EQ 0)//只有一个失压时间
      {
        Write_Storage_Data(SDI_LAST_LOSS_VOL_OCCUR_TIME, (void *)Cur_Time2.Time, 6); 
        Write_Storage_Data(SDI_LAST_LOSS_VOL_END_TIME, (INT8U *)Zero, 6); //最近一次失压结束时刻清0
      }
      return 0;
    }
  }
  
  return 0; 
}

//特殊事件结束处理
INT16U Event_Spec_Separate_End_Proc(INT8U Event_ID, INT8U Flag)
{
  if(Flag EQ EVENT_REAL)
  {
    if(Event_ID EQ ID_EVENT_A_LOSS_VOLT || Event_ID EQ ID_EVENT_B_LOSS_VOLT || Event_ID EQ ID_EVENT_C_LOSS_VOLT)
    {
      if(Get_Event_Total_Occuring_Singles(ID_EVENT_TOTAL_LOSS_VOL) <= 1) //当前是最后一个失压事件了则写入失压结束时间
        Write_Storage_Data(SDI_LAST_LOSS_VOL_END_TIME, (void *)Cur_Time2.Time, 6); 
      return 0;
    }
  }
  
  return 0;
}

//分次事件发生处理
INT16U Event_Separate_Start_Proc(INT8U Event_ID, INT8U Flag)
{
  //INT8U Return_Flag;
  INT8U Data_Flag;
  INT8U i, NextFlag;
  INT16U Index;// Event_Data_Len;
  INT16U Len, Len1;
  STORA_DI SDI;
  /*	
  Len = Extend_Event_Separate_Proc(Event_ID, Occu, Flag, &Return_Flag);
  if(Return_Flag EQ 1)
  {
  return Len;
}
  */	
  TRACE();
  
  Len = Event_Spec_Separate_Start_Proc(Event_ID, Flag);
  if(Len > 0)
    return Len;
  
  Index = Get_Event_Separate_Data_Index(Event_ID);
  if(NULL_2BYTES EQ Index) //没有找到该事件在Event_Separate_Data_Info中的索引，返回0
  {
    ASSERT_FAILED();
    return 0;
  }
  
  Debug_Print("Event_Separate_Start_Proc ID:%d, Occur!", Event_ID);
  if(memcmp((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> Occur_Mask), (INT8U *) Zero, sizeof((Event_Separate_Data_Info[Index].pData) -> Occur_Mask)) EQ 0)//发生时需要记录数据项
  {
    Debug_Print("NO such event!");
    return 0;
  }
  
  if(Event_Separate_Data_Info[Index].Storage_Num EQ 0)
  {
    Debug_Print("Event Storage Num == 0!!");
    return 0;
  }
  
  //下面先生成事件记录的数据
  Len = 0;
  
  SDI = Read_Last_Event_SDI(Event_ID);
  
  if(SDI EQ NULL_EVENT_STORA_DI) //该事件没有发生过
  {
    SDI = Event_Separate_Data_Info[Index].SDI;
  }
  
  //如果是事件发生，且是多记录事件, 则需要在原记录DI基础上 + 1
  SDI  ++;
  if(!(SDI >= Event_Separate_Data_Info[Index].SDI && \
    SDI < Event_Separate_Data_Info[Index].SDI + Event_Separate_Data_Info[Index].Storage_Num))
    SDI = Event_Separate_Data_Info[Index].SDI;
  
  //OS_Mutex_Pend(PUB_BUF0_SEM_ID);
  Pub_Buf0[0] = EVENT_OCCUR;  //第0字节记录当前是发生或者结束
  Len = 1;
  
  //生成当前事件的数据
  for(i = 0; i < (Event_Separate_Data_Info[Index].pData) -> Data_Num; i ++)
  {
    //如果是需要计算差量的数据项目，则生成新的数据后计算差量
    //该数据项是差类型的数据项，则需要获取到源数据(非BCD)
    //Data_Flag = (Get_Array_Bit((Event_Separate_Data_Info[Index].pData) -> Diff_Mask,  i) != 0) ? FOR_SRC:FOR_COMM; 
    //获取对应的645数据项
    Data_Flag = FOR_EVENT;
    if(Get_Array_Bit((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> Diff_Mask), i) != 0)
      Data_Flag |= FOR_SRC;
    
    Len1 = _Get_DLT645_Data((Event_Separate_Data_Info[Index].pData) -> PDI[i], (void *) 0, 0, (INT8U *) Pub_Buf0 + Len, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0), Data_Flag, &NextFlag);
    if(Len1 EQ 0)
    {
      ASSERT_FAILED();
      return 0;
    }
    //某数据项在事件发生时不填充数据，则发生时置0
    if(Get_Array_Bit((INT8U *) (Event_Separate_Data_Info[Index].pData) -> Occur_Mask, i) EQ 0)
      mem_set((INT8U *) Pub_Buf0 + Len, 0, Len1, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0));
    
    Len += Len1;
    if(Len > sizeof(Pub_Buf0))
    {
      ASSERT_FAILED();		
      return 0;
    }
  }
  
  if(SDI != NULL_STORA_DI && Len > 0 && EVENT_REAL EQ Flag)
  {
    //保存时间内容并将最近一次的存储DI保存到Last_SDI指向的存储区域
    if(Write_Storage_Data(SDI, (INT8U *) Pub_Buf0, Len) EQ 1)
      Write_Storage_Data(Event_Separate_Data_Info[Index].Last_SDI, &SDI, sizeof(STORA_DI));
  }
  
  //OS_Mutex_Post(PUB_BUF0_SEM_ID);
  return Len;
  
}

//判断某事件虚拟结束时，是否应该将结束数据进行加减运算
//其他都应该置0
//Event_ID表示事件ID,Data_Index 表示该事件的第i个数据项，是否需要j进行运算
INT8U Check_Event_Data_Add_Dec(INT8U Event_ID, INT8U Data_Index)
{
  //需量超限数据在虚拟事件结束时不能置0
  if(Event_ID EQ ID_EVENT_POS_ACT_DEMAND_EXCEED ||\
     Event_ID EQ ID_EVENT_NEG_ACT_DEMAND_EXCEED ||\
     Event_ID EQ ID_EVENT_Q1_REAC_DEMAND_EXCEED ||\
     Event_ID EQ ID_EVENT_Q2_REAC_DEMAND_EXCEED ||\
     Event_ID EQ ID_EVENT_Q3_REAC_DEMAND_EXCEED ||\
     Event_ID EQ ID_EVENT_Q4_REAC_DEMAND_EXCEED)
  {
     if(Data_Index EQ 2 || Data_Index EQ 3) //超限期间最大需量和需量发生时间不进行减运算 
        return 0;
  }
  else if(Event_ID EQ ID_EVENT_CURR_NO_EVEN || ID_EVENT_VOLT_NO_EVEN) //电压电流不平衡
  {
     if(Data_Index EQ 17) //超限期间最大不平衡率
       return 0;
  }
  
  return 1;
}

//分次事件结束处理
//Flag表示是真实事件结束，还是虚拟事件结束
INT16U Event_Separate_End_Proc(INT8U Event_ID, INT8U Flag)
{
  INT8U* p;//Return_Flag;
  INT8U Data_Flag;
  INT8U i, NextFlag;
  INT16U Index, Event_Data_Len;
  INT16U Len, Len1;
  STORA_DI SDI;
  
  TRACE();	
  
  Len = Event_Spec_Separate_End_Proc(Event_ID, Flag);
  if(Len > 0)
    return Len;
  
  Index = Get_Event_Separate_Data_Index(Event_ID);
  if(NULL_2BYTES EQ Index) //没有找到该事件在Event_Separate_Data_Info中的索引，返回0
  {
    ASSERT_FAILED();
    return 0;
  }
  
  Debug_Print("Event_Separate_End_Proc ID:%d, End!", Event_ID);
  if(memcmp((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> End_Mask), (INT8U *) Zero,\
    sizeof((Event_Separate_Data_Info[Index].pData) -> End_Mask)) EQ 0)//发生时不需要记录数据项
  {
    Debug_Print("NO such event!");
    return 0;
  }
  
  if(Event_Separate_Data_Info[Index].Storage_Num EQ 0)
  {
    Debug_Print("Event Storage Num == 0!!");
    return 0;
  }    
  //下面先生成事件记录的数据
  Len = 0;
  
  SDI = Read_Last_Event_SDI(Event_ID);
  
  if(SDI EQ NULL_EVENT_STORA_DI) //该事件没有发生过
  {
    SDI = Event_Separate_Data_Info[Index].SDI;
  }
  
  //OS_Mutex_Pend(PUB_BUF0_SEM_ID);//申请Pub_Buf0的信号量 
  
  Event_Data_Len = 0;
  //如果是事件结束，且是多记录事件，且在事件发生和结束时都要记录数据, 则需要读取最近一次发生的事件记录
  //只有发生或结束时需要记录则不需读取
  if(memcmp((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> Occur_Mask), (INT8U *) Zero, sizeof((Event_Separate_Data_Info[Index].pData) -> Occur_Mask)) != 0 && \
    memcmp((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> End_Mask), (INT8U *) Zero, sizeof((Event_Separate_Data_Info[Index].pData) -> End_Mask)) != 0)
  {
    //Last_Data_Flag = 0;//是否成功读取到上次事件发生时的数据, 1表示读取到，0表示失败
    
    if(SDI != NULL_STORA_DI)
    {
      //读出事件发生时的数据，没有读出则返回错误
      Event_Data_Len = Read_Last_Event_Data(Event_ID, SDI, (INT8U *) Pub_Buf0, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0));
      if(!(Event_Data_Len EQ (Event_Separate_Data_Info[Index].pData)  ->  Data_Len))// && Event_Data_Len <= (sizeof(Pub_Buf0)/2)))
      {
        ASSERT_FAILED();
        return 0;
      }
      
      if(Pub_Buf0[0] != EVENT_OCCUR)
      {
        ASSERT_FAILED();
        return 0;
      }
      //此时SDI就是该次事件需要存储的DI
      
    }
    else
      return 0;
  }
  Pub_Buf0[0] = EVENT_END;  //第0字节记录当前是发生或者结束
  Len = 1;
  
  //生成当前事件的数据
  for(i = 0; i < (Event_Separate_Data_Info[Index].pData) -> Data_Num; i ++)
  {
    
    Data_Flag = FOR_EVENT;
    if(Get_Array_Bit((INT8U *) ((Event_Separate_Data_Info[Index].pData) -> Diff_Mask), i) != 0)
    {
      if(Check_Event_Data_Add_Dec(Event_ID, i) EQ 1) //是否需要进行减运算?  
        Data_Flag |= FOR_SRC;
    }
    
    p = (INT8U *) Pub_Buf0 + Event_Data_Len + Len;//(sizeof(Pub_Buf0)/2);
    Len1 = _Get_DLT645_Data((Event_Separate_Data_Info[Index].pData) -> PDI[i], (void *) 0, 0, p, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0), Data_Flag, &NextFlag);
    if(Len1 EQ 0)
      ASSERT_FAILED();
    
    if(Get_Array_Bit((INT8U *) (Event_Separate_Data_Info[Index].pData) -> End_Mask, i) != 0)
    {
      if(Get_Array_Bit((INT8U *) (Event_Separate_Data_Info[Index].pData) -> Diff_Mask, i) != 0)    //计算发生和结束之间的数据差
      {
        if(Check_Event_Data_Add_Dec(Event_ID, i) EQ 1) //是否需要进行减运算?
          Proto_Data_Add_Dec(FOR_COMM, DATA_DEC, (PROTO_DI *) &((Event_Separate_Data_Info[Index].pData) -> PDI[i]), 1, p, (INT8U *)Pub_Buf0 + Len, (INT8U *)Pub_Buf0 + Len, (INT8U *)Pub_Buf0, sizeof(Pub_Buf0));
        else
          mem_cpy((INT8U *) Pub_Buf0 + Len, p, Len1, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0));      
      }
      else
      {
        if(EVENT_REAL EQ Flag)
          mem_cpy((INT8U *) Pub_Buf0 + Len, p, Len1, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0));
        else //虚拟事件发生时，将结束时数据置0
          mem_set((INT8U *) Pub_Buf0 + Len, 0, Len1, (INT8U *) Pub_Buf0, sizeof(Pub_Buf0));
      }
    }
    Len += Len1;
  }
  
  if(SDI != NULL_STORA_DI && Len > 0 && EVENT_REAL EQ Flag)
  {
    //保存时间内容并将最近一次的存储DI保存到Last_SDI指向的存储区域
    if(Write_Storage_Data(SDI, (INT8U *) Pub_Buf0, Len) EQ 1)
      Write_Storage_Data(Event_Separate_Data_Info[Index].Last_SDI, &SDI, sizeof(STORA_DI));
  }
  
  //OS_Mutex_Post(PUB_BUF0_SEM_ID);
  
  return Len;
}
//该函数用来生成并存储报警事件数据
//Event_ID表示事件的ID
//Occur_Or_End 表示是该事件的发生还是结束, 用两个宏表示EVENT_OCCUR和EVENT_END
//返回NO_ERR表示成功，其他表示失败
INT16U Event_Separate_Proc(INT8U Event_ID, INT8U Occur_Or_End, INT8U Flag)
{
  INT8U Return_Flag;
  INT16U Len;
  
  TRACE();
  
  Debug_Print("Event_Separate_Proc ID:%d",Event_ID);
  Len = Extend_Event_Separate_Proc(Event_ID, Occur_Or_End, Flag, &Return_Flag);
  if(Return_Flag EQ 1)
    return Len;
  
  OS_Mutex_Pend(PUB_BUF0_SEM_ID);
  
  if(Occur_Or_End EQ EVENT_OCCUR)
    Len = Event_Separate_Start_Proc(Event_ID, Flag);
  else
    Len = Event_Separate_End_Proc(Event_ID, Flag);
  
  OS_Mutex_Post(PUB_BUF0_SEM_ID);
  
  return Len;
}

//设置默认的事件参数与数据
//请分次事件数据
//Clr_Flag 0表示只清Event_Separate_Data_Info[i].Clr_Flag==1的数据
//Clr_Flag 1表示清楚所有的分次事件数据
void Clr_Event_Seperate_Data(INT8U Clr_Flag)
{
  INT16U i, j, Len;
  STORA_DI SDI;
  
  TRACE();
  Debug_Print("Set Def Event Data");
  
  OS_Mutex_Pend(PUB_BUF0_SEM_ID);
  
  mem_set((void *) Pub_Buf0, 0, sizeof(Pub_Buf0), (void *) Pub_Buf0, sizeof(Pub_Buf0));
  for(i = 0; i < S_NUM(Event_Separate_Data_Info); i ++)
  {
    SDI = 0;
    
    if(Event_Separate_Data_Info[i].Clr_Flag EQ 0 && Clr_Flag EQ 0)//Clr_Flag==0表示不清除该数据
      continue;
    
    Len = Read_Storage_Data(Event_Separate_Data_Info[i].Last_SDI, &SDI, &SDI, sizeof(SDI));
    if(Len > 0 && SDI EQ NULL_EVENT_STORA_DI) //该事件没有发生过，不需要清除
      continue;
    
    SDI = NULL_EVENT_STORA_DI; //用次表示该事件没有发生过
    Write_Storage_Data(Event_Separate_Data_Info[i].Last_SDI, (void *) &SDI, sizeof(SDI));
    
    for(j = 0; j < Event_Separate_Data_Info[i].Storage_Num; j ++)
    {
      SDI = Event_Separate_Data_Info[i].SDI + j;// & 0xFFFFFF00) + Hex2Bcd_Byte(j);
      Len = Get_Storage_Data_Len(SDI);
      Write_Storage_Data(SDI, (void *) Pub_Buf0, Len);
    }
  }
  
  Write_Storage_Data(SDI_LAST_LOSS_VOL_OCCUR_TIME, (void *)Zero, 6);//最近一次失压发生和结束时刻
  Write_Storage_Data(SDI_LAST_LOSS_VOL_END_TIME, (void *)Zero, 6);
  
  OS_Mutex_Post(PUB_BUF0_SEM_ID);
  
}

//设置默认的事件分次数据，所有分次数据都置默认
void Set_Def_Event_Separate_Data()
{
  Clr_Event_Seperate_Data(1);
  
}

//清除分次事件,清事件记录时调用该函数
//因为清除事件记录，只需要清除那些Event_Separate_Data_Info.Clr_Flag为1的事件
//该函数不同于Set_Def_Event_Separate_Data，Set_Def_Event_Separate_Data函数
void Clear_Event_Separate_Data()
{
  Clr_Event_Seperate_Data(0); 
}

//清除一个独立事件
INT8U Clear_One_Event_Separate_Data(INT8U Event_ID)
{
  INT16U Index, i, Len;
  STORA_DI SDI;
  
  Index= Get_Event_Separate_Data_Index(Event_ID);
  if(Index EQ NULL_2BYTES)
    return 0; 
  
  if(Event_Separate_Data_Info[Index].Clr_Flag EQ 0)//该数据不允许清除
    return 0;

  DISP_CLR_DATA_INFO;
  
  if(Event_ID EQ ID_EVENT_PROG)
    Clr_Prog_Record_Ram();  
  
  OS_Mutex_Pend(PUB_BUF0_SEM_ID);
 
  mem_set((void *)Pub_Buf0, 0, sizeof(Pub_Buf0), (void *)Pub_Buf0, sizeof(Pub_Buf0));
  
  for(i = 0; i < Event_Separate_Data_Info[Index].Storage_Num; i ++)
  {
    SDI = Event_Separate_Data_Info[Index].SDI + i;
    Len = Get_Storage_Data_Len(SDI);
    Write_Storage_Data(SDI, (void *)Pub_Buf0, Len);
  }
  
  SDI = NULL_EVENT_STORA_DI;
  Write_Storage_Data(Event_Separate_Data_Info[Index].Last_SDI, &SDI, sizeof(SDI));
  OS_Mutex_Post(PUB_BUF0_SEM_ID);
  return 1;
}

//检查PDI是否是一个事件PDI
INT8U Check_Event_Clr_PDI(PROTO_DI PDI)
{
  INT16U Index;
  
  if((PDI & 0xFF) != 0xFF) //格式要求最后一个字节是FF
    return 0;
  
  //事件总清
  if(PDI EQ 0xFFFFFFFF)
    return 1;

  //电压统计统计清除
  if((PDI & 0xFFFF0000) EQ 0x03100000 && ((PDI >> 8) & 0xFF) <= 3)
    return 1;

  //清除总失压累计数据或者前一次失压发生和结束时间
  if(PDI EQ 0x100000FF || PDI EQ 0x100001FF || PDI EQ 0x100002FF) 
    return 1;
  
  PDI = Get_Event_Separate_Start_PDI(PDI);
  PDI = ((PDI & 0xFFFFFF00) | 0x01);
  
  //分次清除
  Index = Get_Event_Separate_Proto_Index(PDI);// != NULL_2BYTES)
  if(Index != NULL_2BYTES && Event_Separate_Data_Info[Index].Clr_Flag EQ 1)  
    return 1;

  
  return 0;
}
#undef EVENT_SEPARATE_C


